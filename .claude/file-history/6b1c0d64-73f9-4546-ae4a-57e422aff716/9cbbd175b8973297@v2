<?php

declare(strict_types=1);

namespace App\Http\Controllers;

use App\Http\Controllers\Traits\HandlesCompositeProfileIds;
use App\Models\Conversation;
use Illuminate\Http\Request;
use Inertia\Inertia;
use Inertia\Response;

class InboxController extends Controller
{
    use HandlesCompositeProfileIds;

    public function index(Request $request): Response
    {
        $selectedProfileId = $request->cookie('selected_profile_id');
        $profile = $this->getSelectedProfile($request, $selectedProfileId);

        if (! $profile) {
            return Inertia::render('inbox/list', [
                'conversations' => [],
            ]);
        }

        $profileType = $profile instanceof \App\Models\InfluencerProfile ? 'influencer' : 'brand';
        $profileIdColumn = $profileType === 'influencer' ? 'influencer_profile_id' : 'brand_profile_id';

        $conversations = Conversation::where($profileIdColumn, $profile->id)
            ->with([
                'brandProfile',
                'influencerProfile',
                'messages' => fn ($query) => $query->latest('sent_at')->limit(1)->with('senderUser'),
            ])
            ->orderBy('last_message_at', 'desc')
            ->get()
            ->map(function ($conversation) use ($profileType) {
                $counterparty = $profileType === 'influencer'
                    ? $conversation->brandProfile
                    : $conversation->influencerProfile;

                $lastMessage = $conversation->messages->first();
                $subtitle = 'No messages yet';

                if ($lastMessage) {
                    $senderUser = $lastMessage->senderUser;
                    $messagePreview = strlen($lastMessage->content) > 50
                        ? substr($lastMessage->content, 0, 50).'...'
                        : $lastMessage->content;
                    $subtitle = ($senderUser?->name ?? 'Unknown').': '.$messagePreview;
                }

                return [
                    'id' => $conversation->id,
                    'title' => $counterparty?->name ?? 'Unknown',
                    'subtitle' => $subtitle,
                    'lastActivityAt' => $conversation->last_message_at?->diffForHumans() ?? 'No activity',
                    'unreadCount' => 0, // TODO: Implement message read tracking
                    'archived' => $conversation->archived,
                    'last_message_at' => $conversation->last_message_at,
                ];
            });

        $systemConversation = (object) [
            'id' => 'system',
            'title' => 'Notifications',
            'subtitle' => 'System notifications and updates',
            'lastActivityAt' => $profile->notifications()->latest()->first() ?
                $profile->notifications()->latest()->first()->created_at->diffForHumans() : 'No activity',
            'unreadCount' => $profile->unreadNotifications()
                ->whereIn('type', [
                    \App\Notifications\ReauthenticationRequired::class,
                ])
                ->count(),
            'archived' => false,
            'last_message_at' => $profile->notifications()->latest()->first()?->created_at,
            'is_system' => true,
        ];

        $conversations = collect([$systemConversation])->merge($conversations);

        return Inertia::render('inbox/list', [
            'conversations' => $conversations,
        ]);
    }

    public function system(Request $request): Response
    {
        $selectedProfileId = $request->cookie('selected_profile_id');
        $profile = $this->getSelectedProfile($request, $selectedProfileId);

        if (! $profile) {
            return Inertia::render('inbox/index', [
                'conversations' => [],
                'notifications' => [],
                'selectedConversationId' => 'system',
            ]);
        }

        $profileType = $profile instanceof \App\Models\InfluencerProfile ? 'influencer' : 'brand';
        $profileIdColumn = $profileType === 'influencer' ? 'influencer_profile_id' : 'brand_profile_id';

        $conversations = Conversation::where($profileIdColumn, $profile->id)
            ->with([
                'brandProfile',
                'influencerProfile',
                'messages' => fn ($query) => $query->latest('sent_at')->limit(1)->with('senderUser'),
            ])
            ->orderBy('last_message_at', 'desc')
            ->get()
            ->map(function ($conversation) use ($profileType) {
                $counterparty = $profileType === 'influencer'
                    ? $conversation->brandProfile
                    : $conversation->influencerProfile;

                $lastMessage = $conversation->messages->first();
                $subtitle = 'No messages yet';

                if ($lastMessage) {
                    $senderUser = $lastMessage->senderUser;
                    $messagePreview = strlen($lastMessage->content) > 50
                        ? substr($lastMessage->content, 0, 50).'...'
                        : $lastMessage->content;
                    $subtitle = ($senderUser?->name ?? 'Unknown').': '.$messagePreview;
                }

                return [
                    'id' => $conversation->id,
                    'title' => $counterparty?->name ?? 'Unknown',
                    'subtitle' => $subtitle,
                    'lastActivityAt' => $conversation->last_message_at?->diffForHumans() ?? 'No activity',
                    'unreadCount' => 0, // TODO: Implement message read tracking
                    'archived' => $conversation->archived,
                    'last_message_at' => $conversation->last_message_at,
                ];
            });

        $notifications = $profile->notifications()
            ->orderBy('created_at', 'desc')
            ->get()
            ->map(function ($notification) {
                return [
                    'id' => $notification->id,
                    'type' => $notification->data['type'] ?? 'notification',
                    'content' => $notification->data['message'],
                    'data' => $notification->data,
                    'sent_at' => $notification->created_at,
                    'read_at' => $notification->read_at,
                    'is_system_message' => true,
                ];
            });

        $systemConversation = (object) [
            'id' => 'system',
            'title' => 'Notifications',
            'subtitle' => 'System notifications and updates',
            'lastActivityAt' => $notifications->isNotEmpty() ?
                $notifications->first()['sent_at']->diffForHumans() : 'No activity',
            'unreadCount' => $profile->unreadNotifications()
                ->whereIn('type', [
                    \App\Notifications\ReauthenticationRequired::class,
                ])
                ->count(),
            'archived' => false,
            'last_message_at' => $notifications->isNotEmpty() ? $notifications->first()['sent_at'] : null,
            'is_system' => true,
        ];

        $conversations = collect([$systemConversation])->merge($conversations);

        dispatch(function () use ($profile) {
            // Only mark system-related notifications as read
            $profile->unreadNotifications()
                ->whereIn('type', [
                    \App\Notifications\ReauthenticationRequired::class,
                ])
                ->get()
                ->markAsRead();
        })->afterResponse();

        return Inertia::render('inbox/index', [
            'conversations' => $conversations,
            'notifications' => $notifications,
            'selectedConversationId' => 'system',
        ]);
    }
}
